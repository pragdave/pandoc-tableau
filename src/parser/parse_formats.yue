--                              Global     Selector
--     fg(color)                   Y          Y
--     bg(color)                   Y          Y
--     align([lcrj][tmb])          Y          Y
--     width(n)                    N          Y 
--     lines([ []_~ ]+)            N          Y 
--     style(a,b,c)                Y          Y
--     header                      N          Y
--     footer                      N          Y
--
--     cols( colspec, colspec...)  Y          N
--     hlines                      Y          N
--     vlines                      Y          N
--     boxed                       Y          N

import "parser.util" as { :dump, :expect }

const color_names = {
  azure:   true,
  black:   true,
  blue:    true,
  brown:   true,
  cyan:    true,
  gray:    true,
  green:   true,
  magenta: true,
  olive:   true,
  purple:  true,
  red:     true,
  teal:    true,
  violet:  true,
  white:   true,
  yellow:  true,
}

const color_hx3 = "#%x%x%x"
const color_hx6 = "#%x%x%x%x%x%x"

gather_one_colspec = () -> "to be defined below"

--------------------------------------------------------------------------------
named_color = (text) ->
  text\save_place()
  name = text\scan("%a+%f[%A]")
  unless name and color_names[name]
    text\restore_place()
    return nil

  suffix = text\scan("%d%f[%D]") |> tonumber
  { color_type: "named-color", :name, :suffix }

--------------------------------------------------------------------------------
known_color = (text) ->
  rgb = text\scan(color_hx6) or text\scan(color_hx3) 
  if rgb
    { color_type: "rgb", name: rgb }
  else
    named_color(text)

--------------------------------------------------------------------------------
-- any word
any_color = (text) ->
  col = text\scan("[%w%-%_]+%f[^%w%-%_]")
  if col
    { color_type: "any-color", name: col }

--------------------------------------------------------------------------------
--     align([lcrj][tmb])   l c r j t m b
align = (text) ->
  spec = nil
  if text\scan("align%(")
    spec = expect(align, text, "expecting alignment specifier [lcrj][tmb]")
    text\expect("%)", "expected closing parenthesis after alignment specifier")
  else
    if text\scan("[lcrj][tmb]%f[%A]") or text\scan("[lcrj]%f[%A]") or text\scan("[tmb]%f[%A]")
      spec = { type: "align", spec: text.last_match }
  spec

--------------------------------------------------------------------------------
--     boxed
boxed = (text) ->
  if text\scan("boxed%f[%A]") or text\scan("box%f[%A]")
    { type: "boxed" }

--------------------------------------------------------------------------------
--     cols(colspec, ...)
cols = (text) ->
  return unless text\scan("cols?%(%s*")
  specs = {}
  spec = gather_one_colspec(text)
  while spec
    specs[]= spec
    text\skip("%s*,%s*")
    spec = gather_one_colspec(text)
  text\expect("%s*%)%s*", "missing close parenthesis after colspecs")
  specs

--------------------------------------------------------------------------------
--    any color
color = (text, ground) ->
  spec = nil
  if text\scan("#{ground}%(")
    unless spec = known_color(text)
      spec = expect(any_color, text, "expecting color")
    text\expect("%)", "expected a single-word color name followed by a ')' ")

  if spec
    text\skip("%s*")
    spec.type = ground
  spec

--------------------------------------------------------------------------------
--     bg/fg(color)
bg = (text) ->
  spec = color(text, "bg") or known_color(text)
  if spec
    spec.type = "bg"
  spec 

fg = (text) ->
  color(text, "fg")


--------------------------------------------------------------------------------
--     footer
footer = (text) ->
  if text\scan("footer%f[%A]") or text\scan("foot%f[%A]")
    { type: "footer" }

--------------------------------------------------------------------------------
--     header
header = (text) ->
  if text\scan("header%f[%A]") or text\scan("head%f[%A]")
    { type: "header" }

--------------------------------------------------------------------------------
--     hlines
hlines = (text) ->
  if text\scan("hlines%f[%A]")
    { type: "hlines" }

--------------------------------------------------------------------------------
--     lines([ []_~ ]+)     [ ] _ ~
lines = (text) ->
  spec = nil
  if text\scan("lines?%(")
    spec = expect(lines, text, "expecting line specifier, one or more of: ] _ ~ [")
    text\expect("%)", "expected closing parenthesis after line specifier")
  else
    if text\scan("[%[%]_~]+")
      spec = { type: "lines", spec: text.last_match }
  spec

--------------------------------------------------------------------------------
--     style = .name
style = (text) ->
  spec = nil
  if text\scan("%.[%w_-]+")
    spec = string.sub(text.last_match, 2)
    text\scan("%s*")
  
  if spec
    { type: "style", :spec }


--------------------------------------------------------------------------------
--     vlines
vlines = (text) ->
  if text\scan("vlines%f[%A]")
    { type: "vlines" }

--------------------------------------------------------------------------------
--     width(n)             [0-9]
width = (text) ->
  spec = nil
  if text\scan("width%(")
    spec = expect(width, text, "expecting an integer width")
    text\expect("%)", "expected closing parenthesis after width")
  else
    if text\scan("[1-9][0-9]*") 
      spec = { type: "width", spec: text.last_match |> tonumber }
  spec



--------------------------------------------------------------------------------
gather_one_colspec = (text) ->
  specs = {}
  valid_specs = (text) -> align(text) or width(text) or lines(text) or fg(text) or bg(text)
  spec = valid_specs(text)
  while spec
    specs[] = spec
    text\skip("%s*")
    spec = valid_specs(text)
  specs


--------------------------------------------------------------------------------
export parse_global_formats = (text) ->
  cols(text) or
  align(text) or 
    bg(text) or 
    fg(text) or 
    style(text) or 
    hlines(text) or
    vlines(text) or
    boxed(text)


--------------------------------------------------------------------------------
export parse_selector_formats = (text) ->
  text\skip("%s+")
  return if text\empty()

  align(text) or 
    bg(text) or 
    fg(text) or 
    footer(text) or
    header(text) or
    lines(text) or 
    style(text) or 
    width(text)
